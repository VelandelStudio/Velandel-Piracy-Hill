//Copyright 2018, Davin Carten, All rights reserved

using UnityEngine;
//using UnityEngine.Networking;
using emotitron.Network.Compression;
using emotitron.Utilities.GUIUtilities;
using System;
using System.Collections.Generic;
using emotitron.Utilities.BitUtilities;

#if UNITY_EDITOR
using UnityEditor;
#endif
namespace emotitron.Network.NST
{

	[DisallowMultipleComponent]
	[ExecuteInEditMode]
	public class NSTMaster : Singleton<NSTMaster>
	{
		public const string DEFAULT_GO_NAME = "NST Master";

		// the num of bits used to count how many bytes an update used - this is a bit arbitrary
		internal const int UPDATELENGTH_BYTE_COUNT_SIZE = 6;

		// Preallocated reusable byte arrays for the bitstream and outstream
		internal static byte[] bitstreamByteArray = new byte[1024];
		internal static byte[] outstreamByteArray = new byte[1024];

		// List of components capable of creating offtick updates
		public static List<IOfftickSrc> iOfftickSrc = new List<IOfftickSrc>();

#if UNITY_EDITOR
		private bool needsEditorModePostAwakeCheck;
#endif
		protected override void Awake()
		{
			base.Awake();

#if UNITY_EDITOR
			// Don't run awake if this is not runtime.
			if(!Application.isPlaying)
			{
				/*EnsureNSTMasterConforms();
				needsEditorModePostAwakeCheck = true;*/
				return;
			}
#endif
			DontDestroyOnLoad(gameObject);
		}



		private void Update()
		{

			// Don't actually try to execute in editmode. We only want the Awake() to fire in edit, not the rest.
#if UNITY_EDITOR
			if (!Application.isPlaying)
			{
				/*if (needsEditorModePostAwakeCheck)
				{
					NetAdapterTools.RemovedUnusedNetworkIdentity(gameObject);
					needsEditorModePostAwakeCheck = false;
				}*/
				return;
			}
#endif

			if (!MasterNetAdapter.NetworkIsActive)
				return;

			for (int i = 0; i < NSTTools.allNsts.Count; i++)
			{
				NSTTools.allNsts[i].MasterUpdate();
			}
		}

		private static int _updateCounter;
		public static int UpdateCounter
		{
			get { return _updateCounter; }
			private set { _updateCounter = (value > 59) ? value - 60 :  (value < 0) ? value + 60 : value; }
		}

		private static int fixedUpdateCounter;
		private void FixedUpdate()
		{
			if (!MasterNetAdapter.ClientIsActive && !MasterNetAdapter.ServerIsActive)
				return;

			if (fixedUpdateCounter == HeaderSettings.single.TickEveryXFixed)
				fixedUpdateCounter = 0;

			if (fixedUpdateCounter == 0)
			{
				PollForUpdates(_updateCounter, false);
				UpdateCounter++;
			}
			else
			{
				// Check for Offticks on nsts marked as allowing offtick
				PollForUpdates(60, true);
			}

			fixedUpdateCounter++;
		}

		// Create the master bitstream and poll for updates
		private static void PollForUpdates(int updateCounter, bool isOfftick)
		{
			UdpBitStream bitstream = new UdpBitStream(NSTMaster.bitstreamByteArray);
			UdpBitStream outstream = new UdpBitStream();

			bitstream.WriteInt(updateCounter, 6);

			bool updatesFound = PollAllForNSTUpdates(ref bitstream, isOfftick ? NSTTools.allNstsWithOfftick : NSTTools.allNsts, updateCounter, isOfftick);

			if (!isOfftick)
				MasterRTT.Send(ref bitstream, updateCounter);

			/// Additional Data after NST Updates added to stream here
			
			// Send every tick, or if anything offtick was found
			if (updatesFound || !isOfftick)
			{
				MasterNetAdapter.SendUpdate(ref bitstream, ref outstream);
			}
			
		}

		private void LateUpdate()
		{
			for (int i = 0; i < NSTTools.allNsts.Count; i++)
				NSTTools.allNsts[i].MasterLateUpdate();
		}

		/// <summary>
		/// Ping all owned NSTs for any due updates (fires on network ticks, generated by the NSTMaster FixedUpdate()). Passes the bitstream to that NST.
		/// </summary>
		public static bool PollAllForNSTUpdates(ref UdpBitStream bitstream, List<NetworkSyncTransform> nsts, int updateCounter, bool isOfftick)
		{
			if (!MasterNetAdapter.ServerIsActive && !MasterNetAdapter.ClientIsActive)
				return false;
			
			bool foundUpdate = false;
			int count = nsts.Count;
			for (int i = 0; i < count; ++i)
			{
				foundUpdate |= nsts[i].PollForUpdate(ref bitstream, updateCounter, isOfftick);
			}

			// Write the end of stream marker of 00
			bitstream.WriteBool(false);

			IntegrityCheck.WriteCheck(ref bitstream);

			return foundUpdate;
		}

		private static NetworkSyncTransform lastNST;

		/// <summary>
		/// Reads update headers for each NST frame update in the incoming bitstream, and passes the bitstream to that NST to read out its
		/// update information.
		/// </summary>
		/// <param name="mirror">True if this is the server, and this is the incoming bitstream. Tells the server that the outstream
		/// needs to be populated for retransmission to all clients. Also false if this is the server running its own outgoing update.</param>
		public static void ReceiveUpdate(ref UdpBitStream bitstream, ref UdpBitStream outstream, bool mirror, int senderId)
		{
			// Create a new bitstream to ensure ptr is at 0. Same data as master though.
			bitstream.Ptr = 0;

			int frameid = bitstream.ReadInt(6);
			if (mirror)
				outstream.WriteInt(frameid, 6);

			bool isOfftick = frameid == 60;

			// remove this safety once working
			//TEST
			int safety = 0;
			UpdateType updateType;
			do
			{
				safety++;
				BandwidthUsage.Start(ref bitstream, BandwidthLogType.UpdateRcv);

				//stop looking when header is EOS
				bool notEOS = bitstream.ReadBool();
				int mirrorUpdateStartPtr = outstream.Ptr;
				BandwidthUsage.AddUsage(ref bitstream, "NotEOS");

				if (mirror)
					outstream.WriteBool(notEOS);


				if (!notEOS)
				{
					break;
				}

				// First three bits are the msgtype 
				//TODO this might only need to be two
				updateType = (UpdateType)bitstream.ReadInt(3);
				BandwidthUsage.AddUsage(ref bitstream, "UpdateType");

				int updateBitstreamPos = outstream.Ptr;
				if (mirror)
					outstream.WriteInt((int)updateType, 3);

				// Next variable is the NstId - get it to know where to send the rest of the bitstream
				uint nstid = bitstream.ReadUInt(HeaderSettings.single.BitsForNstId);
				BandwidthUsage.AddUsage(ref bitstream, "NstId");

				if (mirror)
					outstream.WriteUInt(nstid, HeaderSettings.single.BitsForNstId);

				lastNST = NSTTools.GetNstFromId(nstid);
				BandwidthUsage.SetName(lastNST);

				int updatelength = bitstream.ReadInt(UPDATELENGTH_BYTE_COUNT_SIZE);
				if (mirror)
					outstream.WriteInt(updatelength, UPDATELENGTH_BYTE_COUNT_SIZE);
				BandwidthUsage.AddUsage(ref bitstream, "DataLength");

				//Note the starting pos in stream
				int bodyPtr = bitstream.Ptr;
				// The start pos for modifying update lenght for mirror
				int mirrorBodyPtr = outstream.Ptr;


				// This mising NST handler is NOT FULLY TESTED. Uses the updatelength value to jump ahead in the bitstream if the NST it is
				// addressed to doesn't exist for some reason.
				if (lastNST == null)
				{
					//DebugX.LogWarning(!DebugX.logWarnings ? null : 
					DebugX.Log(
						("Message for an NST Object " + nstid + " arrived but that object does not exist. (yet/anymore?) This is normal during startup and shutdown."));
					// Forward to the next update start in the incoming stream.
					bitstream.Ptr = bodyPtr + (updatelength << 3);
					// rewind to the EOS marker and pretend this arrival never occured for the outgoing mirror stream.
					outstream.Ptr = mirrorUpdateStartPtr;
					continue;
				}

				// Tell this nst to read its mail. updateType may get modified by server receive for things like teleport.
				Frame frame = lastNST.ReadUpdate(ref bitstream, ref outstream, frameid, isOfftick, updateType, updatelength, mirror);
				updateType = frame.updateType;

				// overwrite the updateType of the server outgoing in case it has changed.
				if (mirror)
					outstream.WriteIntAtPos((int)updateType, 3, updateBitstreamPos);

				//Advance ptr to next update in stream by force, in case the last update wasn't read for any reason (such as the NST leaving the game)
				bitstream.Ptr = bodyPtr + (updatelength << 3);
				
				// write the update byte length for the mirror (not the same value as the incoming due to server side adjustments)
				if (mirror)
				{
					int holdPos = outstream.Ptr;
					outstream.Ptr = mirrorBodyPtr - UPDATELENGTH_BYTE_COUNT_SIZE;
					// get the bytesused rounded up.
					int bytes = ((holdPos - mirrorBodyPtr) >> 3) + (((holdPos - mirrorBodyPtr) % 8 == 0 ) ? 0 : 1 );
					outstream.WriteInt(bytes, UPDATELENGTH_BYTE_COUNT_SIZE);
					outstream.Ptr = mirrorBodyPtr + (bytes << 3);
				}


			} while (safety < 100);

			/// NST updates are finished - any data to append to the master update can go here
			IntegrityCheck.ReadCheck(ref bitstream, ref outstream, "End of All Update Reads", mirror);

			MasterRTT.Rcv(ref bitstream, ref outstream, mirror, senderId);
			BandwidthUsage.AddUsage(ref bitstream, "RTT checks");

			// Very last... thing report the bits that were used.
			BandwidthUsage.ReportMasterBits(ref bitstream, BandwidthLogType.MasterIn);

		}

#if UNITY_EDITOR

	/*	public void EnsureNSTMasterConforms()
		{
			//GameObject nstMasterPrefab = Resources.Load("NST Master", typeof(GameObject)) as GameObject;
			gameObject.EnsureRootComponentExists<NSTMaster>();
			gameObject.EnsureRootComponentExists<MasterNetAdapter>();

			if (MasterNetAdapter.NetLib == NetworkLibrary.UNET)
				gameObject.EnsureRootComponentExists<UnityEngine.Networking.NetworkIdentity>();
			else
			{
				UnityEngine.Networking.NetworkIdentity ni = gameObject.GetComponent<UnityEngine.Networking.NetworkIdentity>();
				if (ni)
					UnityEngine.Object.DestroyImmediate(ni, true);
			}

			if (PrefabUtility.GetPrefabType(gameObject) == PrefabType.PrefabInstance)
				PrefabUtility.RevertPrefabInstance(gameObject);
		}*/
#endif
	}
	

#if UNITY_EDITOR

	[CustomEditor(typeof(NSTMaster))]
	[CanEditMultipleObjects]
	public class NSTMasterEditor : NSTHeaderEditorBase
	{
		NSTMaster _target;
		public override void OnEnable()
		{
			headerName = HeaderMasterName;
			headerColor = HeaderSettingsColor;
			base.OnEnable();

			//_target = (NSTMaster)target;

			//_target.EnsureNSTMasterConforms();
			//// Remove any stray NetworkIdentities that do not belong
			//NetAdapterTools.RemovedUnusedNetworkIdentity(_target.gameObject);
		}

		public override void OnInspectorGUI()
		{
			//NetAdapterTools.EnsureSceneNetLibDependencies();


			base.OnInspectorGUI();

			//EditorGUILayout.HelpBox("The NST Master is a required engine singleton. It collects and sends all NST Updates, and receives and dispatches incoming updates from the network to their associated NSTs.", MessageType.None);

			//_target.EnsureNSTMasterConforms();

			//NetLibrarySettings.Single.DrawGui(target, true, false);
		}
	}
#endif
}

